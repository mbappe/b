Run makewrap to see if the builds work.  It will run for days (maybe not).
Run bbwrap to see if the code works.  It will run for days (maybe not).
Run bbwrapq for a less vigorous test.  It will run for days (maybe not).
rcs.tjz contains a copy of the RCS files in case the originals be found.
Look for symbolic names in the RCS files.
CP140405 is Checkpoint April 5, 2014.

Questions:
- Which is faster to search?  Which is more memory efficient?
  A long list of 16-bit keys.  A 64K bit bitmap is 1K words.  A 1K word list
  contains 4K keys.  That's a long list.
  Several lists of 8-bit keys, each with an 8-bit prefix.
  Do we want the lists contiguous?  Or can we use a separate pointer for each?
  A bitmap with 256 bits is only four 64-bit words.  A pointer is one word.
  Three words of list is one 8-bit prefix and 23 keys.
- Does it make sense to have level specific behavior?  Or is it possible
  to maximize performance while minimizing level specific behavior?
- Is it better to do an unconditional prefix check or to test to see if a
  prefix check is necessary before doing the prefix check?  If the test
  to see is just as expensive as the check itself, then it doesn't make
  sense to do the test.  The prefix is a little more computation, but is
  it any more conditional branches?  The prefix check requires reading the
  prefix/pop word which may be an additional cache line if it is not in
  the link.

To do:
- Parallel search.
- Level-specific bits per digit.
- Use type values greater than current level for other things.
- Use ls_nDigitsLeft/ls_wPrefix to implement skip link to list.
- Allow lists at cnDigitsAtBottom.

... Old ...

Mike's high performance binary tree.

Start with a basic binary tree and use compression techniques to improve
memory usage and performance.

- use immediate values, adjacent memory and/or various sized short pointers
  to replace word-sized/long pointers
- discard unnecessary sub-key bits
- widen nodes from single bit to more
- pull node parameters into pointer above
- use bitmaps at bottom
- discard full bitmaps
- use population count to trigger some transformations, e.g. node merging
- use lists instead of uncompressed wide nodes/leaves
- use bitmapped nodes for wide nodes/leaves


